         /////////////////////////////////////////////  
        //   IoT AI-driven Food Irradiation Dose   // 
       //        Detector w/ Edge Impulse         //
      //           -----------------             //
     //            (Beetle ESP32-C3)            //           
    //             by Kutluhan Aktar           // 
   //                                         //
  /////////////////////////////////////////////

// 
// Collate weight, color, and emitted ionizing radiation of foods to train a NN. Then, run it on Beetle C3 to detect food irradiation doses.
//
// For more information:
// https://www.theamplituhedron.com/projects/IoT_AI_driven_Food_Irradiation_Dose_Detector_w_Edge_Impulse
//
//
// Connections
// Beetle ESP32-C3 : 
//                                Gravity: Geiger Counter Module
// D5   --------------------------- D
// VCC  --------------------------- +
// GND  --------------------------- -
//                                Gravity: I2C 1Kg Weight Sensor Kit - HX711
// VCC  --------------------------- VCC
// GND  --------------------------- GND
// D9   --------------------------- SCL
// D8   --------------------------- SDA
//                                Fermion: 1.51” SSD1309 OLED Transparent Display
// D4   --------------------------- SCLK
// D6   --------------------------- MOSI
// D7   --------------------------- CS
// D2   --------------------------- RES
// D1   --------------------------- DC
//                                AS7341 11-Channel Spectral Color Sensor
// VCC  --------------------------- +
// GND  --------------------------- -
// D9   --------------------------- C
// D8   --------------------------- D
//                                Control Button (A)
// D0   --------------------------- +
//                                Control Button (B)
// D20  --------------------------- +
//                                Control Button (C)
// D21  --------------------------- +


// Include the required libraries:
#include <DFRobot_Geiger.h>
#include <DFRobot_HX711_I2C.h>
#include <U8g2lib.h>
#include <SPI.h>
#include "DFRobot_AS7341.h"

// Include the Edge Impulse model converted to an Arduino library:
#include <IoT_AI-driven_Food_Irradiation_Classifier_inferencing.h>

// Define the required parameters to run an inference with the Edge Impulse model.
#define FREQUENCY_HZ        EI_CLASSIFIER_FREQUENCY
#define INTERVAL_MS         (1000 / (FREQUENCY_HZ + 1))

// Define the features array to classify one frame of data.
float features[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE];
size_t feature_ix = 0;

// Define the threshold value for the model outputs (predictions).
float threshold = 0.60;

// Define the food irradiation dose (class) names:
String classes[] = {"Hazardous", "Regulated", "Unsafe"};

// Define the Geiger counter module.
DFRobot_Geiger geiger(5);

// Define the HX711 weight sensor.
DFRobot_HX711_I2C MyScale;

// Define the AS7341 object.
DFRobot_AS7341 as7341;
// Define AS7341 data objects:
DFRobot_AS7341::sModeOneData_t data1;
DFRobot_AS7341::sModeTwoData_t data2;

// Define the 1.51” OLED transparent display (SSD1309).
#define OLED_DC  1
#define OLED_CS  7
#define OLED_RST 2

U8G2_SSD1309_128X64_NONAME2_1_4W_HW_SPI u8g2(/* rotation=*/U8G2_R0, /* cs=*/ OLED_CS, /* dc=*/ OLED_DC,/* reset=*/OLED_RST);

// Define monochrome graphics:
static const unsigned char error_bits[] U8X8_PROGMEM = {
   0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x0f, 0x00, 0x00, 0xfc,
   0xff, 0x3f, 0x00, 0x00, 0xfe, 0xff, 0x7f, 0x00, 0x80, 0xff, 0xff, 0xff,
   0x01, 0xc0, 0xff, 0x81, 0xff, 0x03, 0xe0, 0xff, 0x00, 0xff, 0x07, 0xf0,
   0xff, 0x00, 0xff, 0x0f, 0xf0, 0x7f, 0x00, 0xfe, 0x0f, 0xf8, 0x7f, 0x00,
   0xfe, 0x1f, 0xfc, 0x7f, 0x00, 0xfe, 0x3f, 0xfc, 0xff, 0x00, 0xff, 0x3f,
   0xfe, 0xff, 0x00, 0xff, 0x7f, 0xfe, 0xff, 0x00, 0xff, 0x7f, 0xfe, 0xff,
   0x00, 0xff, 0x7f, 0xfe, 0xff, 0x00, 0xff, 0x7f, 0xff, 0xff, 0x00, 0xff,
   0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
   0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0x81,
   0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0x81, 0xff, 0xff,
   0xfe, 0xff, 0xc3, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff,
   0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xc3, 0xff,
   0x3f, 0xfc, 0xff, 0x81, 0xff, 0x3f, 0xf8, 0xff, 0x81, 0xff, 0x1f, 0xf0,
   0xff, 0x81, 0xff, 0x0f, 0xf0, 0xff, 0x81, 0xff, 0x0f, 0xe0, 0xff, 0xc3,
   0xff, 0x07, 0xc0, 0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0x01,
   0x00, 0xfe, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff, 0x3f, 0x00, 0x00, 0xf0,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00
};
static const unsigned char regulated_bits[] U8X8_PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00,
   0x34, 0x00, 0x30, 0x84, 0x03, 0x00, 0x00, 0x62, 0x12, 0x50, 0x44, 0x02,
   0x00, 0x00, 0x42, 0x36, 0x28, 0x88, 0x03, 0x00, 0x00, 0x8a, 0x36, 0x28,
   0x08, 0x00, 0x00, 0x00, 0x8a, 0x3e, 0x14, 0x08, 0x00, 0x00, 0x00, 0x92,
   0x3e, 0x14, 0x08, 0x30, 0x00, 0x00, 0xd4, 0x7c, 0x14, 0x08, 0x2f, 0x00,
   0x40, 0x5c, 0x9c, 0x15, 0xcc, 0x20, 0x00, 0xa0, 0x70, 0x04, 0x09, 0x74,
   0x42, 0x00, 0xa0, 0x20, 0x02, 0x0a, 0x5a, 0x42, 0x00, 0xe0, 0x40, 0x02,
   0x92, 0x89, 0x41, 0x00, 0x00, 0x40, 0x8c, 0x53, 0x04, 0x43, 0x00, 0x00,
   0x8e, 0x04, 0x72, 0x14, 0x4c, 0x00, 0x00, 0x19, 0x08, 0x02, 0x12, 0x70,
   0x00, 0x80, 0xf0, 0x38, 0x02, 0x12, 0x40, 0x00, 0xe0, 0x00, 0x11, 0x72,
   0x0a, 0x40, 0x00, 0x10, 0x00, 0xb1, 0x52, 0x0a, 0x20, 0x00, 0x08, 0x80,
   0x60, 0x52, 0x0a, 0x20, 0x00, 0x48, 0x40, 0x40, 0x22, 0x02, 0x10, 0x00,
   0xd0, 0x43, 0x5c, 0x02, 0x02, 0x08, 0x00, 0x10, 0x40, 0x96, 0x02, 0x03,
   0x06, 0x00, 0x10, 0x92, 0x94, 0x83, 0x81, 0x01, 0x00, 0x10, 0xb7, 0x08,
   0xe3, 0xe0, 0x00, 0x00, 0xe0, 0xa5, 0x00, 0xc0, 0x37, 0x00, 0x00, 0x00,
   0xff, 0x01, 0x80, 0x3f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x03,
   0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00,
   0x00, 0x02, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x11,
   0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x03, 0x00,
   0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x46, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x84, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x08, 0x03,
   0x00, 0x40, 0x00, 0x00, 0x00, 0x10, 0x06, 0x00, 0x20, 0x00, 0x00, 0x00,
   0x20, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x0c, 0x00,
   0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00
};
static const unsigned char unsafe_bits[] U8X8_PROGMEM = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0xe0, 0x3f, 0x00, 0x00, 0x00,
   0xf8, 0x01, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0xf8, 0x01,
   0x00, 0x00, 0x3f, 0x00, 0x01, 0xf0, 0x03, 0x00, 0x00, 0x0f, 0x80, 0x01,
   0xc0, 0x03, 0x00, 0xc0, 0x07, 0x80, 0x00, 0xc0, 0x07, 0x00, 0xc0, 0x03,
   0x80, 0x00, 0xe0, 0x0f, 0x00, 0xe0, 0x01, 0x40, 0x00, 0xf0, 0x1f, 0x00,
   0xe0, 0x00, 0x00, 0x00, 0x78, 0x3c, 0x00, 0xf0, 0x58, 0x6b, 0x03, 0x38,
   0x3c, 0x00, 0x78, 0xfc, 0xff, 0x07, 0x1e, 0x78, 0x00, 0x78, 0xfc, 0xff,
   0x07, 0x0f, 0x70, 0x00, 0x38, 0x00, 0x00, 0x80, 0x07, 0xf0, 0x00, 0x3c,
   0x74, 0x77, 0xc7, 0x03, 0xf0, 0x00, 0x1c, 0xfc, 0xff, 0xe7, 0x01, 0xe0,
   0x00, 0x1c, 0xfc, 0xff, 0xf7, 0x00, 0xe0, 0x00, 0x1c, 0xf8, 0xff, 0x7b,
   0x00, 0xe0, 0x01, 0x1e, 0xf8, 0xff, 0x38, 0x00, 0xc0, 0x01, 0x0e, 0xf8,
   0xff, 0x1e, 0x00, 0xc0, 0x01, 0x0e, 0xf8, 0x3f, 0xdf, 0x01, 0xc0, 0x01,
   0x1e, 0xf8, 0xbf, 0x07, 0x0c, 0xc0, 0x01, 0x0e, 0xf0, 0xcf, 0x23, 0x21,
   0xc0, 0x01, 0x1e, 0xf0, 0xef, 0x01, 0x40, 0xc0, 0x01, 0x1e, 0xf0, 0xf3,
   0x90, 0x94, 0xe0, 0x01, 0x1c, 0xf0, 0x7b, 0x02, 0x00, 0xc0, 0x01, 0x1c,
   0xf0, 0x7c, 0x02, 0x80, 0xe0, 0x00, 0x1c, 0xe0, 0x9e, 0xff, 0xff, 0xe0,
   0x00, 0x3c, 0x20, 0xdf, 0xff, 0xff, 0xe0, 0x00, 0x38, 0xa0, 0xe7, 0xff,
   0xff, 0xf0, 0x00, 0x38, 0xc0, 0x47, 0x55, 0x95, 0x70, 0x00, 0x78, 0xe0,
   0x01, 0x00, 0x00, 0x78, 0x00, 0x70, 0xe0, 0x04, 0x00, 0x80, 0x38, 0x00,
   0xf0, 0x78, 0x28, 0x49, 0x52, 0x3c, 0x00, 0xe0, 0x3d, 0x00, 0x00, 0x00,
   0x1e, 0x00, 0xc0, 0x1f, 0x00, 0x00, 0x00, 0x1e, 0x00, 0xc0, 0x0f, 0x00,
   0x00, 0x80, 0x0f, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x80, 0x07, 0x00, 0x00,
   0x1f, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x7e, 0x00, 0x00, 0xf0, 0x01,
   0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x80,
   0x3f, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xfd, 0x1f, 0x00, 0x00, 0x00, 0x80,
   0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00
};
static const unsigned char hazardous_bits[] U8X8_PROGMEM = {
   0x00, 0x00, 0xa0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0xff, 0x02,
   0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x17,
   0xa0, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x7c, 0x00, 0x00, 0x00,
   0x7c, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0xe0, 0x03,
   0x00, 0x80, 0x07, 0x00, 0x01, 0x80, 0x03, 0x00, 0xc0, 0x03, 0xe0, 0x1f,
   0x00, 0x07, 0x00, 0xc0, 0x01, 0xf0, 0x3f, 0x00, 0x0e, 0x00, 0xe0, 0x00,
   0xfc, 0xff, 0x00, 0x1c, 0x00, 0x70, 0x00, 0xfe, 0xff, 0x01, 0x38, 0x00,
   0x70, 0x00, 0xff, 0xff, 0x03, 0x38, 0x00, 0x38, 0x00, 0xff, 0xff, 0x03,
   0x70, 0x00, 0x18, 0x00, 0xff, 0xff, 0x03, 0x60, 0x00, 0x1c, 0x80, 0xff,
   0xff, 0x07, 0xe0, 0x00, 0x1c, 0x80, 0xff, 0xff, 0x07, 0xc0, 0x00, 0x0c,
   0x80, 0xff, 0xff, 0x07, 0xc0, 0x00, 0x0e, 0x80, 0x03, 0x83, 0x07, 0xc0,
   0x01, 0x0e, 0x80, 0x01, 0x01, 0x07, 0xc0, 0x01, 0x0e, 0x80, 0x01, 0x03,
   0x06, 0x80, 0x01, 0x06, 0x00, 0x03, 0x03, 0x03, 0x80, 0x03, 0x06, 0x00,
   0x83, 0x07, 0x03, 0x80, 0x01, 0x07, 0x00, 0xd6, 0xef, 0x01, 0x80, 0x03,
   0x07, 0x00, 0xfc, 0xff, 0x00, 0x80, 0x03, 0x07, 0x10, 0x78, 0x38, 0x00,
   0x80, 0x03, 0x06, 0x30, 0x70, 0x3b, 0x70, 0x80, 0x03, 0x06, 0x78, 0xf0,
   0x3f, 0x70, 0x80, 0x01, 0x06, 0x78, 0xd0, 0x2f, 0xf8, 0x80, 0x03, 0x0e,
   0xfc, 0xc1, 0x0f, 0xfc, 0xc0, 0x01, 0x06, 0xfc, 0x43, 0x0b, 0xff, 0x80,
   0x01, 0x0e, 0x80, 0x0f, 0xc0, 0x03, 0xc0, 0x01, 0x0c, 0x00, 0x1e, 0xe0,
   0x01, 0xc0, 0x01, 0x0e, 0x00, 0x7c, 0xfc, 0x00, 0xc0, 0x00, 0x1c, 0x00,
   0xf0, 0x3f, 0x00, 0xe0, 0x00, 0x18, 0x00, 0xc0, 0x0f, 0x00, 0x60, 0x00,
   0x38, 0x00, 0xc0, 0x1f, 0x00, 0x70, 0x00, 0x78, 0x00, 0xfe, 0xff, 0x01,
   0x38, 0x00, 0x70, 0x00, 0x7e, 0xf8, 0x01, 0x38, 0x00, 0xe0, 0x01, 0x1e,
   0xf0, 0x01, 0x1c, 0x00, 0xc0, 0x03, 0x1c, 0xe0, 0x00, 0x0f, 0x00, 0xc0,
   0x07, 0x1c, 0xc0, 0x00, 0x07, 0x00, 0x80, 0x07, 0x00, 0x00, 0xc0, 0x03,
   0x00, 0x00, 0x0f, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x7c, 0x00, 0x00,
   0xf0, 0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x7e, 0x00, 0x00, 0x00, 0xe0,
   0x0f, 0xa0, 0x1f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x07, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x27, 0x00,
   0x00, 0x00
};

// Create an array including icons for labels (classes).
static const unsigned char *class_icons[] U8X8_PROGMEM = {hazardous_bits, regulated_bits, unsafe_bits}; 

// Define the control button pins:
#define button_A 0
#define button_B 20
#define button_C 21

// Define the data holders:
float weight;
volatile boolean model_activation = false; 
int predicted_class = -1;

void setup() {
  Serial.begin(9600);

  pinMode(button_B, INPUT_PULLUP);

  // Initialize the SSD1309 transparent display.
  u8g2.begin();
  u8g2.setFontPosTop();
  //u8g2.setDrawColor(0);
  
  // Check the connection status between the weight (HX711) sensor and the Beetle ESP32-C3.
  while (!MyScale.begin()) {
    Serial.println("HX711 initialization is failed!");
    err_msg();
    delay(1000);
  }
  Serial.println("HX711 initialization is successful!");
  
  // Set the calibration weight (g) to calibrate the weight sensor automatically.
  MyScale.setCalWeight(100);
  // Set the calibration threshold (g).
  MyScale.setThreshold(30);
  // Display the current calibration value. 
  Serial.print("\nCalibration Value: "); Serial.println(MyScale.getCalibration());
  MyScale.setCalibration(MyScale.getCalibration());
  delay(1000);

  // Check the connection status between the AS7341 visible light sensor and the Beetle ESP32-C3.
  while (as7341.begin() != 0) {
    Serial.println("AS7341 initialization is failed!");
    err_msg();
    delay(1000);
  }
  Serial.println("AS7341 initialization is successful!");

  // Enable the built-in LED on the AS7341 sensor.
  as7341.enableLed(true);

  delay(1000);
}

void loop() {
  get_Weight();
  get_Visual_Light();
  activate_Geiger_counter();

  // Show the collected data on the screen.
  home_screen(8, 90, 20);

  // Execute the Edge Impulse model to make predictions on the food irradiation doses (classes).
  if(!digitalRead(button_B)){
    model_activation = true;
    u8g2.firstPage();  
    do{
      u8g2.setFont(u8g2_font_open_iconic_all_8x_t);
      u8g2.drawGlyph(/* x=*/32, /* y=*/0, /* encoding=*/233);  
    }while(u8g2.nextPage());
  }
  while(model_activation){
    get_Weight();
    get_Visual_Light();
    activate_Geiger_counter();

    // Run inference:
    run_inference_to_make_predictions(1);

    // If the Edge Impulse model predicted a label (class) successfully:
    if(predicted_class != -1){
      // Display the predicted class:
      String c = "Class: " + classes[predicted_class];
      int str_x = c.length() * 4;
      u8g2.firstPage();  
      do{
        //u8g2.setBitmapMode(true /* transparent*/);
        u8g2.drawXBMP( /* x=*/(u8g2.getDisplayWidth()-50)/2 , /* y=*/0 , /* width=*/50 , /* height=*/50 , class_icons[predicted_class]);
        u8g2.setFont(u8g2_font_4x6_tr);
        u8g2.drawStr((u8g2.getDisplayWidth()-str_x)/2, 55, c.c_str());
      }while(u8g2.nextPage());      
      
      // Clear the predicted class (label).
      predicted_class = -1;

      // Stop the running inference and return to the home screen.
      model_activation = false;
    }
  }
}

void run_inference_to_make_predictions(int multiply){
  // Scale (normalize) data items depending on the given model:
  float scaled_weight = weight / 10;
  float scaled_F1 = data1.ADF1 / 100;
  float scaled_F2 = data1.ADF2 / 100;
  float scaled_F3 = data1.ADF3 / 100;
  float scaled_F4 = data1.ADF4 / 100;
  float scaled_F5 = data2.ADF5 / 100;
  float scaled_F6 = data2.ADF6 / 100;
  float scaled_F7 = data2.ADF7 / 100;
  float scaled_F8 = data2.ADF8 / 100;
  float scaled_CPM = geiger.getCPM() / 100;
  float scaled_nSv = geiger.getnSvh() / 100;
  float scaled_uSv = geiger.getuSvh();
  
  // Copy the scaled data items to the features buffer.
  // If required, multiply the scaled data items while copying them to the features buffer.
  for(int i=0; i<multiply; i++){  
    features[feature_ix++] = scaled_weight;
    features[feature_ix++] = scaled_F1;
    features[feature_ix++] = scaled_F2;
    features[feature_ix++] = scaled_F3;
    features[feature_ix++] = scaled_F4;
    features[feature_ix++] = scaled_F5;
    features[feature_ix++] = scaled_F6;
    features[feature_ix++] = scaled_F7;
    features[feature_ix++] = scaled_F8;
    features[feature_ix++] = scaled_CPM;
    features[feature_ix++] = scaled_nSv;
    features[feature_ix++] = scaled_uSv;
  }

  // Display the progress of copying data to the features buffer.
  Serial.print("\nFeatures Buffer Progress: "); Serial.print(feature_ix); Serial.print(" / "); Serial.println(EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE);
  
  // Run inference:
  if(feature_ix == EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE){    
    ei_impulse_result_t result;
    // Create a signal object from the features buffer (frame).
    signal_t signal;
    numpy::signal_from_buffer(features, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);
    // Run the classifier:
    EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);
    ei_printf("\nrun_classifier returned: %d\n", res);
    if(res != 0) return;

    // Print the inference timings on the serial monitor.
    ei_printf("Predictions (DSP: %d ms., Classification: %d ms., Anomaly: %d ms.): \n", 
        result.timing.dsp, result.timing.classification, result.timing.anomaly);

    // Obtain the prediction results for each label (class).
    for(size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++){
      // Print the prediction results on the serial monitor.
      ei_printf("%s:\t%.5f\n", result.classification[ix].label, result.classification[ix].value);
      // Get the predicted label (class).
      if(result.classification[ix].value >= threshold) predicted_class = ix;
    }
    Serial.print("\nPredicted Class: "); Serial.println(predicted_class);

    // Detect anomalies, if any:
    #if EI_CLASSIFIER_HAS_ANOMALY == 1
      ei_printf("Anomaly : \t%.3f\n", result.anomaly);
    #endif

    // Clear the features buffer (frame):
    feature_ix = 0;
  }
}

void home_screen(int y, int x, int s){
  u8g2.firstPage();  
  do{
    u8g2.setFont(u8g2_font_open_iconic_all_2x_t);
    u8g2.drawGlyph(/* x=*/0, /* y=*/y-3, /* encoding=*/142);
    u8g2.drawGlyph(/* x=*/0, /* y=*/y+s-3, /* encoding=*/259);
    u8g2.drawGlyph(/* x=*/0, /* y=*/y+(2*s)-3, /* encoding=*/280);
    u8g2.setFont(u8g2_font_freedoomr10_mu);
    u8g2.drawStr(25, y, "WEIGHT:"); drawNumber(x, y, weight);
    u8g2.drawStr(25, y+s, "F1:"); drawNumber(x, y+s, data1.ADF1);
    u8g2.drawStr(25, y+(2*s), "CPM:"); drawNumber(x, y+(2*s), geiger.getCPM());
  }while(u8g2.nextPage());
}

void activate_Geiger_counter(){
  // Initialize the Geiger counter module and enable the external interrupt.
  geiger.start();
  delay(3000);
  // If necessary, pause the count and turn off the external interrupt trigger.
  geiger.pause();
  
  // Evaluate the current CPM (Counts per Minute) by dropping the edge pulse within 3 seconds: the error is ±3CPM.
  Serial.print("\nCPM: "); Serial.println(geiger.getCPM());
  // Get the current nSv/h (nanoSieverts per hour).
  Serial.print("nSv/h: "); Serial.println(geiger.getnSvh());
  // Get the current μSv/h (microSieverts per hour).
  Serial.print("μSv/h: "); Serial.println(geiger.getuSvh());
}

void get_Weight(){
  weight = MyScale.readWeight();
  if(weight < 0.5) weight = 0;
  Serial.print("\nWeight: "); Serial.print(weight); Serial.println(" g");
  delay(1000);
}

void get_Visual_Light(){
  // Start spectrum measurement:
  // Channel mapping mode: 1.eF1F4ClearNIR
  as7341.startMeasure(as7341.eF1F4ClearNIR);
  // Read the value of sensor data channel 0~5, under eF1F4ClearNIR
  data1 = as7341.readSpectralDataOne();
  // Channel mapping mode: 2.eF5F8ClearNIR
  as7341.startMeasure(as7341.eF5F8ClearNIR);
  // Read the value of sensor data channel 0~5, under eF5F8ClearNIR
  data2 = as7341.readSpectralDataTwo();
  // Print data:
  Serial.print("\nF1(405-425nm): "); Serial.println(data1.ADF1);
  Serial.print("F2(435-455nm): "); Serial.println(data1.ADF2);
  Serial.print("F3(470-490nm): "); Serial.println(data1.ADF3);
  Serial.print("F4(505-525nm): "); Serial.println(data1.ADF4);
  Serial.print("F5(545-565nm): "); Serial.println(data2.ADF5);
  Serial.print("F6(580-600nm): "); Serial.println(data2.ADF6);
  Serial.print("F7(620-640nm): "); Serial.println(data2.ADF7);
  Serial.print("F8(670-690nm): "); Serial.println(data2.ADF8);
  // CLEAR and NIR:
  Serial.print("Clear_1: "); Serial.println(data1.ADCLEAR);
  Serial.print("NIR_1: "); Serial.println(data1.ADNIR);
  Serial.print("Clear_2: "); Serial.println(data2.ADCLEAR);
  Serial.print("NIR_2: "); Serial.println(data2.ADNIR);
  delay(1000);
}

void err_msg(){
  // Show the error message on the SSD1309 transparent display.
  u8g2.firstPage();  
  do{
    //u8g2.setBitmapMode(true /* transparent*/);
    u8g2.drawXBMP( /* x=*/44 , /* y=*/0 , /* width=*/40 , /* height=*/40 , error_bits);
    u8g2.setFont(u8g2_font_4x6_tr);
    u8g2.drawStr(0, 47, "Check the serial monitor to see");
    u8g2.drawStr(40, 55, "the error!");
  }while(u8g2.nextPage());
}

void drawNumber(int x, int y, int __){
    char buf[7];
    u8g2.drawStr(x, y, itoa(__, buf, 10));
}
